-module(kaa_proto).

-export([worker/1,
    exec/1
]).

-include("kaa_core.hrl").
-include("kaa.hrl"). % auto-generated by gpb
-include("kaa_worker.hrl"). % auto-generated by gpb
-include("kaa_error.hrl"). % auto-generated by gpb
-include("kaa_result.hrl"). % auto-generated by gpb

worker(Pid) when not is_pid(Pid) ->
    KaaError = #'KaaError'{error = "no_jun_worker"},
    kaa_error:encode_msg(KaaError);
worker(Pid) when is_pid(Pid)     ->
    KaaWorker = #'KaaWorker'{jun_worker = pid_to_list(Pid)},
    kaa_worker:encode_msg(KaaWorker).

exec(PBMsg) when not is_binary(PBMsg) ->
    lager:error("invalid kaa protobuf message ~p", [invalid_binary]),
    KaaError = #'KaaError'{error = "invalid_kaa_proto_message"},
    kaa_error:encode_msg(KaaError);
exec(PBMsg) when is_binary(PBMsg)     ->
    case catch kaa:decode_msg(PBMsg, 'Kaa') of
        {'EXIT', Error}  ->
            lager:error("invalid kaa protobuf message ~p", [Error]),
            KaaError = #'KaaError'{error = "invalid_kaa_proto_message"},
            kaa_error:encode_msg(KaaError);
        #'Kaa'{} = KaaPB ->
            % decompose message and execute through jun!
            JunWorker = list_to_pid(KaaPB#'Kaa'.jun_worker),
            Mod = KaaPB#'Kaa'.module,
            Fn = KaaPB#'Kaa'.'function',
            Result = exec_jun(KaaPB#'Kaa'.arguments, JunWorker, Mod, Fn),
            encode_result(Result)
    end.

%% @hidden

exec_jun({path, Path}, JunWorker, Mod, Fn) ->
    Mod:Fn(JunWorker, list_to_atom(Path));
exec_jun({frame, #m_frame{dataframe = MemId, axis = Axis, keywords = Keywords}},
        JunWorker, Mod, Fn) ->
    Pid = pid_to_list(self()),
    [{_, DataFrame}] = ets:lookup(?KAA_ENVIRONMENT(Pid), MemId),
    % parse keywords in order to convert to a plist for jun
    Keywords0 = lists:map(fun(#'Keywords'{key = Key, value = Value}) ->
        {list_to_atom(Key), list_to_atom(Value)}
    end, Keywords),
    % maybe dont use axis, this must be optional in proto
    case Axis of
        undefined ->
            Mod:Fn(JunWorker, DataFrame, Keywords0);
        _         ->
            % this rare condition happens when jun tries to use a integer value as
            % argument of a function, for example, head or tail.
            % a function could receive a float value?, if so, then parse.
            case catch list_to_integer(Axis) of
                {'EXIT', _} -> Mod:Fn(JunWorker, DataFrame, list_to_atom(Axis), Keywords0);
                AxisInt     -> Mod:Fn(JunWorker, DataFrame, AxisInt, Keywords0)
            end
    end.

%% @hidden

encode_result({ok, {?DATAFRAME, {'$erlport.opaque', python, _} = DataFrame}}) ->
    MemId = random_key(),
    Pid = pid_to_list(self()),
    true = ets:insert(?KAA_ENVIRONMENT(Pid), {binary_to_list(MemId), DataFrame}),
    KaaResult = #'KaaResult'{ok = "ok", result = {dataframe, MemId}},
    kaa_result:encode_msg(KaaResult);
% the process of return plotting through pb is complex, since is an opaque term
% similar to dataframe, so maybe store in an internal storage to execute tasks
% in the plot after creation.
encode_result({ok, {?AXESPLOT, {'$erlport.opaque', python, _} = Plot}}) ->
    PlotBin = term_to_binary(Plot),
    KaaResult = #'KaaResult'{ok = "ok", result = {axesplot, binary_to_list(PlotBin)}},
    kaa_result:encode_msg(KaaResult);
encode_result({ok, I}) when is_integer(I)                       ->
    KaaResult = #'KaaResult'{ok = "ok", result = {inumber, I}},
    kaa_result:encode_msg(KaaResult);
encode_result({ok, F}) when is_float(F)                         ->
    KaaResult = #'KaaResult'{ok = "ok", result = {dnumber, F}},
    kaa_result:encode_msg(KaaResult);
encode_result({ok, B}) when is_binary(B)                        ->
    KaaResult = #'KaaResult'{ok = "ok", result = {string, binary_to_list(B)}},
    kaa_result:encode_msg(KaaResult);
encode_result({ok, S}) when is_list(S)                          ->
    KaaResult = #'KaaResult'{ok = "ok", result = {string, S}},
    kaa_result:encode_msg(KaaResult);
encode_result({error, {Error, Description}})                    ->
    KaaError = #'KaaError'{error = atom_to_list(Error),
        description = Description},
    kaa_error:encode_msg(KaaError).

%% @hidden

random_key() ->
    Seq = lists:seq(1, 100),
    Chars = "abcdeefghijklmnopqrstuvwxyz",
    R = lists:foldl(fun(_, Acc) ->
        L = length(Chars),
        [ lists:nth(rand:uniform(L), Chars) | Acc]
    end, [], Seq),
    list_to_binary(R).
