-module(kaa_proto).

-export([worker/1,
    exec/1
]).

% export samples
-export([read_csv_instruction/2,
    sum_age_instruction/4
]).

-include("kaa.hrl"). % auto-generated by gpb
-include("kaa_worker.hrl"). % auto-generated by gpb
-include("kaa_error.hrl"). % auto-generated by gpb
-include("kaa_result.hrl"). % auto-generated by gpb

worker(Pid) when not is_pid(Pid) ->
    KaaError = #'KaaError'{error = "no_jun_worker"},
    kaa_error:encode_msg(KaaError);
worker(Pid) when is_pid(Pid)     ->
    KaaWorker = #'KaaWorker'{jun_worker = pid_to_list(Pid)},
    kaa_worker:encode_msg(KaaWorker).

exec(PBMsg) when not is_binary(PBMsg) ->
    lager:error("invalid kaa protobuf message ~p", [invalid_binary]),
    KaaError = #'KaaError'{error = "invalid_kaa_proto_message"},
    kaa_error:encode_msg(KaaError);
exec(PBMsg) when is_binary(PBMsg)     ->
    case catch kaa:decode_msg(PBMsg, 'Kaa') of
        {'EXIT', Error}  ->
            lager:error("invalid kaa protobuf message ~p", [Error]),
            KaaError = #'KaaError'{error = "invalid_kaa_proto_message"},
            kaa_error:encode_msg(KaaError);
        #'Kaa'{} = KaaPB ->
            % decompose message and execute through jun!
            JunWorker = list_to_pid(KaaPB#'Kaa'.jun_worker),
            Mod = KaaPB#'Kaa'.module,
            Fn = KaaPB#'Kaa'.'function',
            Result = exec_jun(KaaPB#'Kaa'.arguments, JunWorker, Mod, Fn),
            encode_result(Result)
    end.

%% @hidden

exec_jun({path, Path}, JunWorker, Mod, Fn) ->
    Mod:Fn(JunWorker, list_to_atom(Path));
exec_jun({frame, #m_frame{dataframe = DataFrame, axis = Axis, keywords = Keywords}},
        JunWorker, Mod, Fn) ->
    % parse keywords in order to convert to a plist for jun
    Keywords0 = lists:map(fun(#'Keywords'{key = Key, value = Value}) ->
        {list_to_atom(Key), list_to_atom(Value)}
    end, Keywords),
    % maybe dont use axis, this must be optional in proto
    case Axis of
        undefined ->
            Mod:Fn(JunWorker, binary_to_term(DataFrame), Keywords0);
        _         ->
            Mod:Fn(JunWorker, binary_to_term(DataFrame), list_to_atom(Axis), Keywords0)
    end.

%% @hidden

encode_result({ok, {'$erlport.opaque', python, _} = DataFrame}) ->
    KaaResult = #'KaaResult'{ok = "ok",
        result = {dataframe, term_to_binary(DataFrame)}},
    kaa_result:encode_msg(KaaResult);
encode_result({ok, I}) when is_integer(I)                       ->
    KaaResult = #'KaaResult'{ok = "ok", result = {inumber, I}},
    kaa_result:encode_msg(KaaResult);
encode_result({ok, F}) when is_float(F)                         ->
    KaaResult = #'KaaResult'{ok = "ok", result = {dnumber, F}},
    kaa_result:encode_msg(KaaResult);
encode_result({ok, B}) when is_binary(B)                        ->
    KaaResult = #'KaaResult'{ok = "ok", result = {string, binary_to_list(B)}},
    kaa_result:encode_msg(KaaResult);
encode_result({ok, S}) when is_list(S)                          ->
    KaaResult = #'KaaResult'{ok = "ok", result = {string, S}},
    kaa_result:encode_msg(KaaResult);
encode_result({error, {Error, Description}})                    ->
    KaaError = #'KaaError'{error = atom_to_list(Error),
        description = Description},
    kaa_error:encode_msg(KaaError).

%% Sample of usage for kaa proto encoder
%% This should be implemented from client side, but we put here
%% as a sample and test how works kaa modules. Also clients are
%% responsible for implement result and error proto files. 
read_csv_instruction(JunWorker, PathToCsv) ->
    Kaa = #'Kaa'{module = 'jun_pandas',
        'function' = 'read_csv',
        jun_worker = JunWorker,
        arguments = {path, PathToCsv}},
    kaa:encode_msg(Kaa).

sum_age_instruction(JunWorker, DataFrame, Fn, Axis) ->
    Kaa = #'Kaa'{module = 'jun_pandas',
        'function' = Fn,
        jun_worker = JunWorker,
        arguments = {frame, #m_frame{dataframe = DataFrame, axis = Axis}}},
    kaa:encode_msg(Kaa).
